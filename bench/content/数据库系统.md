{ "title": "数据库系统", "date": "2019-03-01" }

# 数据库系统

## 第1讲 初步认识数据库系统

### 表 (Table)

#### 表的术语

**表名**：表的名称。

**表标题（格式）**：每一列的列名。

**表内容（值）**：表的内容。

**行/元组/记录**：表中的一行。

**列/字段/属性/数据项**：表中的一列。列中分为**列名**与**列值**。

**关系模式**：表名与表标题的组合。

**表/关系**：表名、表标题与表内容的组合。

**数据库**：相互有关联关系的若干表的集合。

### 数据库系统（工作环境）

#### 构成五要素

**数据库(DB)**：相互有关联关系的数据的集合。

**数据库管理系统(DBMS)**：管理数据库的一种系统软件。

**数据库应用程序(DBAP)**：不同用户使用的完成某功能的应用程序。**通过DBMS来使用数据库**。

**数据库管理员(DBA)**：**直接使用DBMS**来创建与管理数据库的人员。

**计算机基本系统**：使得数据库系统能够正常运行的计算机系统。

### 数据库管理系统 (DBMS)

#### 功能（用户角度）

- **数据库定义**：定义数据库中表的**名称**、**标题（包括属性名称及对属性值的要求）**等。
  - DBMS提供一套**数据定义语言(DDL)**，用户使用DDL描述表的格式，并由DBMS创建数据库。
- **数据库操纵**：向数据库的表中增加/删除/更新数据，以及对数据进行查询/检索/统计等。
  - DBMS提供一套**数据操纵语言(DML)**，用户使用DML描述增、删、改、查等操作，并由DBMS执行。
- **数据库控制**：控制数据库中数据的使用，即用户权限。
  - DBMS提供一套**数据控制语言(DCL)**，用户使用DCL描述对数据库的控制，由DBMS实际进行控制。
- **数据库维护**：转储/恢复/重组/性能检测/分析等功能。
  - DBMS提供一系列用于维护数据库的程序，一般由数据库管理员使用和掌握。

#### 数据库语言

**数据定义语言(DDL)**：用于定义数据格式。

**数据操纵语言(DML)**：用于对数据进行操作。

**数据控制语言(DCL)**：用于对数据进行控制。

上述三种语言联合起来形成**SQL语言**，即结构化查询语言。

##### 特点

- 一条数据库语言语句相当于高级语言的一个或多个循环程序。
- 数据库语言分为**嵌入型**（可嵌入到高级语言中使用，高级语言在此称为宿主语言）、**交互型**（可与用户交互）、**双重型**。

#### 功能（系统角度）

从系统实现角度看，DBMS的功能为**形式→构造→自动化**。

一般而言，操作系统管理存储与缓冲区，DBMS管理索引/文件记录与操作实现算法。但**有一些DBMS可越过操作系统直接管理存储与缓冲区**。

DBMS在后台运行着一系列程序：

- **语言编译器**：将用数据库语言书写的内容翻译为DBMS可执行的命令。如DDL编译器。
- **查询优化与查询实现**：执行引擎及基本命令的不同执行算法，提高数据库检索速度。
- **数据存取与索引**：在存储器上高效存取数据。例如存储管理器，缓冲区管理区，索引/文件和记录管理器。
- **通信控制**：网络环境下操作数据库与传输数据。
- **事务管理**：提高可靠性，避免并发错误。
- **故障恢复**：使数据库自动恢复到故障发生前的正确状态。例如备份、运行日志操控。
- **安全性控制**：合法性检验，避免非授权非法用户访问数据库。
- **完整性控制**：检查数据及数据操作的正确性。
- **数据字典管理**：管理用户已经定义的信息。
- **应用程序接口**：使应用程序能够使用DBMS特定功能。
- **数据库数据装载、重组**
- **数据库性能分析**：统计运行过程中数据库的各种性能数据，便于优化。

## 第2讲 数据库系统的结构抽象与演变

### 数据库系统的标准结构

#### 数据（视图）与模式

**数据（视图）**：某一表现形式下表现出来的数据库中的数据。

**模式**：对数据库中数据进行的一种结构性描述。

#### 三级模式两层映像

数据库系统的标准结构包括**用户层次**、**概念层次**、**内部层次**。总结为如下三级模式，两层映像。

##### 三级模式

- **外部模式（用户模式）**：某一用户能够看到与处理的数据的结构描述，是全局数据的一部分。
- **概念模式（全局模式）**：从全局角度管理的数据的结构描述，包含相应的关联约束，体现数据间的内在本质联系。
- **内部模式（物理模式）**：存储在介质上的数据的结构描述，包含存储路径、存储方式、索引方式等。

通常，**模式**默认意为**全局模式**，**视图**默认意为**外部视图**。

##### 两层映像

- **E-C映像**（即External - Conceptual）：将外模式映射为概念模式，支持数据概念视图向外部视图的转换。
- **C-I映像**（即Conceptual - Internal）：将概念模式映射为内模式，支持数据概念视图向内部视图的转换。

DBMS通常允许**用户自定义三级模式**，而通过**程序自动实现两层映像**。

#### 两个独立性

使用数据库系统标准结构可获得两个独立性：

- **逻辑数据独立性**：概念模式变化时，可以不改变外部模式（只需改变E-C映像），从而无需改变应用程序。
- **物理数据独立性**：内部模式变化时，可以不改变概念模式（只需改变C-I映像），从而无需改变外部模式。

两个独立性的意义都在于不会因为存储结构与逻辑结构的变化而影响应用程序。

### 数据模型

**数据模型**：规定模式统一描述方式的模型，是对模式本身结构的抽象。

- **关系模型**：以**表**的形式组织数据。模式需包含表名及若干属性。
- **层次模型**：以**树**的形式组织数据。模式需以树形组织若干**实体型**，实体型间连线称为**系型**。
- **网状模型**：以**图**的形式组织数据。模型形式与层次模型相似，但允许每个节点有多个父节点与子节点。

其余还有面向对象模型、XML模型、NoSQL模型等。

### 数据库系统的演变与发展

#### 由文件系统到数据库

- 文件系统中，数据存取基本以**记录**为单位。
  - 优点：用户无需考虑文件存储的物理细节。
  - 缺点：数据的组织及语义与应用程序紧密相关；文件及文件的记录之间无联系。
- 数据库系统中，数据由DBMS统一存取。数据存取可以以**记录**为单位，也可以以**数据项**和**记录集合**为单位。
  - 意义：多个应用程序可共享数据及数据结构的操作；系统自动检查安全性、完整性和并发正确性；记录之间相互有关联。

#### 由层次模型数据库、网状模型数据库到关系数据库

- **第一代数据库**：**层次模型数据库**与**网状模型数据库**
  - 缺点：由指针系统维系，结构描述复杂；检索依赖于指针系统指示的路径；不能有效支持记录集合的操作。

- **第二代数据库**：**关系数据库**
  - 意义：结构描述简单；检索不依赖于路径信息或过程信息，支持非过程化的数据操作；有效支持记录集合的操作。

#### 由关系数据库到对象关系数据库、面向对象数据库

- 关系数据库需按**关系的第一范式**组织数据，即**数据项是不可再分**的。
- 对象-关系数据库以对象封装需分解的数据项（多值属性和复合属性）。面向对象数据库支持复杂的数据类型，数据封装与抽象数据结构，并支持面向对象的一些特性。
  - 意义：有效支持不满足关系第一范式的数据项。
- XML数据库被称为**半结构化数据库**，面向数据交换而提出，**数据**与**数据的语义**合并在一起存储处理。XML数据库在互联网中得到广泛应用。

#### 由多种多样的数据库到多数据库开放式互连

使用**开放数据库连接(ODBC)**与不同的DBMS交互，从而统一操作多种数据库。

## 第3讲 关系模型之基本概念

### 关系

**域**：一组值的集合，这组值具有相同的数据类型。域是列的取值范围。

**分量**：元组中的每一个值称为一个分量。

**关系**：一组域的笛卡尔积的子集（满足某种意义的子集）。

**属性名**：由于关系的不同列可能来自同一个域，故为每一列起一个名称，即属性名。注意**属性名与域名不同**。

**关系模式/表标题**：用于表示关系的结构，记为$R(A_1:D_1,A_2:D_2,\dots,A_n:D_n)$，可简记为$R(A_1,A_2,\dots,A_n)$。意为属性$A_i$对应于域$D_i$。其中$n$称作关系的**度**或**目**，关系中元组的数目称为关系的**基数**。在许多DBMS中，域一般直接说明为属性的类型、长度等。

**候选码/候选键**：能唯一标识任意一个元组的一个极小属性组（即从中去除任意一个属性便不满足这一性质）。当候选码由所有属性构成时，该关系称为**全码关系**。

**主码/主键**：当有多个候选码时，可以选定一个作为主码。

**主属性**：包含在任意一个候选码中的属性。

**外码/外键**：若一个属性组不是关系$R$的候选码，但与关系$S$的候选码相对应，则称该属性组为$R$的外码/外键。两个关系通常靠外码来连接。

#### 特性

- 关系的任意两个元组不能完全相同，但在现实应用中，**表可能并不完全遵守此特性**。
- **关系第一范式**：属性不可再分。**复合属性**（属性由多个子属性构成）和**多值属性**（同一元组中该属性有多个值）不符合关系第一范式。

### 关系模型

#### 关系模型的三要素

- **基本结构**：关系
- **关系操作**：
  - 基本操作：并，差，积，选择，投影。（有时也将“更名”操作视为基本操作之一）
  - 扩展操作：交，连接，除。
- **完整性约束**：包括**实体完整性**、**参照完整性**及**用户自定义的完整性**。其中，实体完整性和参照完整性由DBMS自动支持，用户自定义的完整性通常由DBMS在更新操作发生时自动检查。
  - **实体完整性**：主码中的属性值不能为空值（不知道或无意义的值，以“?”表示）。
  - **参照完整性**：外码要么取空值，要么取其对应主码关系中出现过的主码值。
  - **用户自定义的完整性**：用户针对具体应用定义的完整性约束条件。

## 第4讲 关系模型之关系代数

### 关系代数操作

#### 并相容性

- 两关系的属性数目相同。
- 两关系按顺序对应属性的域相同。

并、差、交操作需要操作对象满足**并相容性**。

#### 操作定义

- 集合操作：

  - **并（$\cup$）**：$R \cup S=\{t|t \in R \or t \in S\}$
  - **交（$\cap$）**：$R \cap S=\{t|t \in R \and t \in S\}$，或$R \cap S=R-(R-S)$
  - **差（$-$）**：$R-S=\{t|t \in R \and t \notin S\}$
  - **广义积（$\times$）**：$R \times S=\{<a_1,\dots,a_n,b_1,\dots,b_m>|<a_1,\dots,a_n> \in R \and <b_1,\dots,b_m> \in S\}$
    - 由于行位置无关性与列位置无关性，有$R \times S = S \times R$。

- 纯关系操作：

  - **投影（$\pi_A$）**：$\pi_{A_{i1},A_{i2},\dots,A_{ik}}(R)=\{<t[A_{i1}],t[A_{i2}]>,\dots,t[A_{ik}]|t \in R\}$

    - 投影结果的列顺序可以与原顺序不同。
    - 投影后若出现相同元组，应消除掉。
    - 下标若为关系名，则代指该关系拥有的属性；若为关系之差，则代指两关系的属性集之差。
  - **选择（$\sigma_{con}$）**：$\sigma_{con}(R)=\{t|t \in R \and con(t)=\rm{true}\}$

    - 书写条件时，元组$t$的分量$A_i$记为$t[A_i]$，或简写为$A_i$。
  - **连接**：

    - **$\theta$-连接（$\mathop \Join \limits_{A \space\theta\space B}$）**：$R \mathop \Join \limits_{A \space\theta\space B} S=\sigma_{t[A]\space\theta\space s[B]}(R \times S)$，其中$\theta$为比较运算符，$t \in R$，$s \in S$。
      - 一个关系与自身连接时应进行换名，例如$\rho_{S}R$表示将集合$R$换名为$S$。
    - **等值连接**：即特殊的$\theta$-连接，其中$\theta$为$=$。
    - **自然连接（$\Join$）**：$R \Join S=\sigma_{t[B]=s[B]}(R \times S)$，要求$R$与$S$中有若干个相同的属性（组）$B$。
      - 连接后去除重复属性列。
  - **除（$\div$）**：$R \div S=\{t[A]|t \in R \and \{t[A]\} \times S \subseteq R\}$，其中$A$为属于$R$但不属于$S$的属性（组）。
  - **外连接**：连接+失配的元组（与全空元组连接）
    - 分为左外连接、右外连接与全外连接，左/右代指保留哪个方向的失配元组，记号为相应方向多两横。

## 第5讲 关系模型之关系演算

关系演算按照谓词变量的不同，分为**关系元组演算**与**关系域演算**。

### 关系元组演算

关系元组演算表达式的基本形式：$\{t|P(t)\}$，表示所有使谓词$P$为真的元组$t$的集合。其中谓词$P$有递归定义，允许使用的运算符包括$\in$，$\theta$，$\neg$，$\and$，$\or$，$\exist()()$，$\forall()()$。其中，被存在量词$\exist$或全称量词$\forall$限定的元组变量称为**约束变量**，否则称为**自由变量**。

存在量词与全称量词的等价转换：

- $\forall(t \in R)(P(t)) \Leftrightarrow \neg (\exist (t \in P)(\neg P(t)))$
- $\exist(t \in R)(P(t)) \Leftrightarrow \neg (\forall (t \in P)(\neg P(t)))$

### 关系域演算

关系域演算表达式的基本形式：$\{<x_1,x_2,\dots,x_n>|P(x_1,x_2,\dots,x_n)\}$，表示所有使谓词$P$为真的域变量元组的集合。其中$x_i$为域变量或常量，$P$具有与关系元组演算公式相似的递归定义。

#### QBE语言

通过填表进行基于关系域演算的增删改查。

QBE操作框架四部分：关系名，属性名，操作命令，查询条件。

示例元素：用于连接多个条件。当两行间使用不同示例元素时表示或；当两行间使用相同示例元素时表示与；当两表中出现相同示例元素时表示连接两表中对应的属性。

操作命令也可写在查询条件区，表示仅操作该列；与或非运算符也可写在操作命令区，此时将整行看做一个条件（相当于加括号）。

### 关系运算的安全性

安全性：不产生**无限关系**和**无穷验证**的运算称为安全的。

关系代数是有限集合的运算，故是**安全**的；关系演算**不一定是安全**的。

**安全约束有限集合 (DOM) **：$\rm{DOM}(\psi)$是一个有限集，其中每个元素要么是公式$\psi$中的符号，要么是$\psi$中某关系中某元组的某分量。DOM不必是最小集合。

**安全元组演算表达式**：满足以下条件的元组演算表达式$\{t|\psi(t)\}$称为安全表达式。

- 若$t$满足$\psi$，则$t$的每个分量均属于$\rm{DOM}(\psi) $。（保证不产生无限关系）
- 对于$\psi$中形如$(\exist u)(\omega(u))$的子表达式，若$u$满足$\omega$，则$u$的每个分量均属于$\rm{DOM}(\omega)$。（保证不产生存在量词的无穷验证）
- 对于$\psi$中形如$(\forall u)(\omega(u))$的子表达式，若$u$不满足$\omega$，则$u$的每个分量均属于$\rm{DOM}(\omega)$。（保证不产生全称量词的无穷验证）

## 第6-8讲 SQL语言

SQL语言是集DDL、DML、DCL于一体的数据库语言。

### 操作语句

#### DDL操作

- **Create**

  - create database 数据库名;

    创建指定名称的数据库。在创建数据库后，即可在其中创建表。

  - create table 表名(列名 数据类型 \[default \{默认值|Null\}\] \[列约束\] \[\[, 列名 数据类型 \[default \{默认值|Null\}\] \[列约束\]\] ...\]\[, 表约束\]);

    创建指定名称的表，包含指定的属性列，每个属性具有指定的数据类型及可能的默认值与约束。

    - 列约束：\{Not Null|\[constraint 约束名\] \{Unique|Primary key|check (条件)|references 表名\[(列名)\] \[on delete \{Cascade|Set Null\}\]\}\}

      Primary key：**主键约束**，即指定该属性为主键。**每个表仅能包含一个主键约束**。

      Unique：**唯一性约束**，即指定该属性为候选键。每个表可以有多个唯一性约束。

      Not null：**非空约束**，即指定该属性列不允许出现空值。

      check：该列更新时应满足check规定的条件。条件形式同where（其中可包含子查询）。

      references：定义该列为指定表的外键，可在其后指定对应指定表的哪一列。

      on delete：当上述外键对应列某值v被删除时，应如何处理该外键。Cascade表示删除本表中外键为v的元素；Set Null表示将本表中外键为v的元素外键值更新为Null。若无on delete条件则无操作。

    - 表约束：\[constraint 约束名\] \{Unique (列名\[\[, 列名\] ...\])|Primary key (列名\[\[, 列名\] ...\])|check (条件)|Foreign key (列名\[\[, 列名\] ...\]) references 表名 \[(列名\[\[, 列名\] ...\])\] \[on delete Cascade\]\}

  - create view 视图名 \[(列名\[\[, 列名\] ...\])\] as (子查询) \[自定义约束条件\];

    创建指定结构的**视图（外模式）及其E-C映像**，以及用户对元组的自定义约束。当使用DML操作更新元组时，DBMS将自动检查自定义约束是否被满足。

  - create assertion 断言名 check 条件;

    创建断言时及数据库每次更新时，DBMS将检查断言。断言将增加DBMS负担，降低效率。

  - create trigger 触发器名 \{before|after\} \{insert|delete|update \[of 列名\[\[, 列名\] ...\]\]\} on 表名 \[referencing 变量定义\[\[, 变量定义\] ...\]\] \[for each row|for each statement\] \[when (条件)\] \{语句|begin atomic 多行语句 end\};

    before/after：指定在动作执行前或执行后触发。

    for each row / for each statement：指定对每一条记录的修改均触发或对一条SQL语句触发。

    - 变量定义：\{old \[row\] \[as\] 旧元组命名|new \[row\] \[as\] 新元组命名|old table \[as\] 旧表名|new table \[as\] 新表名\}

      用于在条件或语句中引用变量。

- **Alter**

  - alter table 表名 add \{(列名 数据类型 \[default \{默认值|Null\}\]\[\[, 列名 数据类型 \[default \{默认值|Null}]\] ...\][, 表约束])|constraint 约束名\};

  - alter table 表名 drop \{column (列名\[\[, 列名\] ...\])|constraint 约束名|Primary key\};

  - alter table 表名 modify 列名 数据类型 \[default \{默认值|Null\}\] \[列约束]\[\[, 列名 数据类型 \[default \{默认值|Null\}\] \[列约束\]\] ...\];

    修改指定表的定义。add用于增加列或约束，drop用于删除列或约束，modify用于修改列的定义。

    **未命名的约束无法被删除。**

- **Drop**

  - drop table 表名;

    对指定的表删除包括表格式、表中所有元组、由该表导出的视图等所有相关内容。

  - drop database 数据库名;

    删除指定数据库。

  - drop view 视图名;

    删除指定视图。

- Use（仅部分DBMS）

  - use 数据库名;

    在允许操作多个数据库的DBMS中，指定待操作数据库。

- Close（仅部分DBMS）

  - close 数据库名;

    在允许操作多个数据库的DBMS中，关闭数据库。

#### DML操作

- **Insert**

  - insert into 表名\[(列名 \[\[, 列名\] ...\])\] values (值 \[\[, 值\] ...\]);

    向指定表的指定列插入记录。当省略所有列名时，默认表示表中依存储顺序排列的所有列。values后面值的顺序需与语句中的列名顺序一致。

  - insert into 表名\[(列名 \[\[, 列名\] ...\])\] 子查询;

    向指定表的指定列插入子查询结果中的若干元组。

- **Delete**

  - delete from 表名 \[where 条件表达式\];

    删除指定表中满足指定条件的元组。若省略条件，则删除所有元组。

- **Update**

  - update 表名 set 列名=表达式|(子查询)\[\[, 列名= 表达式|(子查询)\] ...\] \[where 条件表达式\];

    更新指定表中满足指定条件的元组的指定列为新的值。新值表达式中可包含属性名及数学符号。

- **Select**

  - select \[Distinct\] 列名\[\[ as\] 别名\] \[\[, 列名\[\[ as\] 别名\]\] ...\] from 表名\[\[ as\] 别名\] \[\[, 表名\[\[ as\] 别名\]\] ...\] \[where 检索条件\] \[group by 分组条件 \[having 分组过滤条件\]\] \[order by 列名 \[asc|desc\]\];

    从表名所给出的表（的笛卡尔积）中，查询满足检索条件的元组，并按照指定的列及其顺序投影显示。相当于$\pi_{列名,\dots, 列名}(\sigma_{检索条件}(表名))$。列名可用“*”表示所有列。检索条件中可使用运算符and、or、not及括号，模糊匹配运算like或not like，空值判断is \[not\] null，以及子查询（详见下文）；多个表中属性名相同时，以“表名.属性名”方式指定属性。列名处也可填写计算表达式及聚集函数，详见下文。

    模糊匹配：通配符“%”匹配零至多个字符；“_”匹配单个任意字符；“\”为转义符。

    属于：in后可跟随表或中间查询结果表。

    Distinct：去除投影后重复的元组。

    group by：将查询结果按某一列/某些列的值进行分组（相同值归为一组），以支持Select中的聚集函数。

    having：过滤出满足指定条件的分组。

    order by：查询结果依指定属性升序（asc）或降序（desc）排列。若省略顺序指定，默认为升序。所依据属性可以不在查询结果中。

**聚集函数**：select语句后除可跟随列名外还可跟随计算表达式或聚集函数。有5个内置聚集函数：

- count(任意变量)：求个数，参数可直接填“\*”。
- sum(数值类型变量)：求和。
- avg(数值类型变量)：求平均。
- max(数值或字符串类型变量)：求最大值。
- min(数值或字符串类型变量)：求最小值。

**子查询**：出现在where语句中的select语句称为子查询。子查询返回一个集合。实际使用中，除使用select语句外，也可直接使用枚举形式写出集合字面量作为返回值，即(元素, 元素, ...)形式。共有三种子查询：

- In子查询

  - 表达式 \[not\] in (子查询)

    判断表达式是否在子查询结果中。

    表达式：列名、常数等。

- $\theta$-Some / $\theta$-All子查询：

  - 表达式 $\theta$ \{some|all\} (子查询)

    some：判断表达式是否至少与子查询结果中某一个值满足$\theta$关系。“表达式 in (子查询)”与“表达式 = some (子查询)”是等价的。

    all：判断表达式是否与子查询结果中所有值均满足$\theta$关系。“表达式 not in (子查询)”与“表达式 <> all (子查询)”是等价的。

- Exists子查询：

  - \[not\] exists (子查询)

    判断子查询结果是否为空集。在不使用not时，往往exists语句也可一并省略。

**相关子查询**：内层查询依靠外层查询的某些参量的，称为相关子查询；否则（内层查询可独立进行的）称为非相关子查询。相关子查询使用的外层参量需要以**外层表名**进行**限定**。

子查询间可使用并交差运算，即union \[All\]、intersect \[All\]、except \[All\]，其中使用All关键字时，重复元组将被保留。进行运算的两子查询结果的**列必须按顺序对应**。

**连接运算**（高级语法）：在from子句中使用。语法为：表名\[Natural\] \[Inner|\{Left|Right|Full\} \[Outer\]\] join 表名 \{on 连接条件 | using (列名 \[\[, 列名\] ...\])\}。连接运算由两部分构成：

- 连接类型：
  - Inner Join：即$\theta$-连接运算。
  - Left Outer Join：即左外连接运算，左表中无法与右表匹配的元组将与空值元组连接。
  - Right Outer Join：即右外连接运算，右表中无法与左表匹配的元组将与空值元组连接。
  - Full Outer Join：前两者的并集。
- 连接条件：
  - Natural：即自然连接，仅连接在所有公共属性上均取值相等的元组。结果中公共属性仅出现一次。
  - On：即$\theta$-连接，On后可跟随连接条件。
  - Using：特殊的自然连接，Using后可指定依据哪些公共属性进行自然连接，指定的属性必须为所有公共属性的子集。

注：新增/删除/更新元组时，DBMS将检查完整性约束，若约束条件不满足，则不会执行动作。

注：视图不可更新的情形：

- select目标包含聚集函数
- select子句使用了unique或distinct
- 包括group by
- 包括经算术表达式计算得到的列
- 由单一表中的列构成，但未包括主键

注：现行DBMS的空值处理策略：

- 除is \[not\] null外，空值不满足任何查找条件。
- 有null参与的算术表达式值为null。
- 有null参与的比较运算值为false。
- 除count()外，其余聚集函数均会忽略空值。

#### DCL操作

- **Grant**

  - grant \{All privileges|权利\[\[, 权利\] ...\]\} on \[table\] \{表名|视图名\} to \{Public|用户账户\[\[, 用户账户\] ...\]\} \[With grant option\];

    授予指定用户指定权利。

    权利：取值范围为\{Select, Insert, Update, Delete, All privileges\}。

    With grant option：允许被授权者传播这些权利。

- **Revoke**

  - revoke \{All privileges|权利\[\[, 权利\] ...\]\} on \{表名|视图名\} from \{Public|用户账户\[\[, 用户账户\] ...\]\};

    收回指定用户的指定权利。

## 第8讲 数据库的完整性和安全性

关于完整性与安全性的SQL语句参见上一讲。

### 数据库完整性

**数据库完整性**：DBMS应保证的DB的在任何情况下的正确性、有效性和一致性。

- **广义完整性**：语义完整性、并发控制、安全控制、DB故障恢复等。
- **狭义完整性**：专指**语义完整性**。

**完整性约束条件**的一般形式：(O, P, A, R)

- O：数据集合，即约束的对象。
- P：谓词条件，即约束内容。
- A：触发条件，即何时检查。
- R：响应动作，即不满足条件时怎么办。

#### 完整性的分类

- 按**约束对象**分类
  - **域完整性约束条件**：对孤立列进行约束条件判断。
  - **关系（表）完整性约束条件**：对元组或关系内/关系间的若干元组间的联系进行约束条件判断。
- 按**约束来源**分类
  - **结构约束**：来自于模型的约束，只关心数值相等与否、是否允许空值等。如实体完整性与参照完整性。
  - **内容约束**：来自于用户的约束，关心元组或属性的取值范围。如用户自定义完整性。
- 按**约束状态**分类
  - **静态约束**：DB在任意时刻均应满足的约束。
  - **动态约束**：DB从一状态变为另一状态时应满足的约束。如限制属性值只升不降。

SQL支持静态约束中的**域完整性约束**与**表完整性约束**（仅需定义O与P），动态约束中的**触发器**机制（需定义O、P、A、R）。

### 数据库安全性

**数据库安全性**：DBMS应该保证的数据库免受非法、非授权用户的使用、泄露、更改或破坏的特性。

#### 安全性的分类

- 自主安全性机制：存取控制

  由用户自主传递权限。

- 强制安全性机制：

  对数据和用户进行强制分类，使不同用户能够访问不同类别的数据。

- 推断控制机制：

  防止从数据库公开信息通过推断获得私密信息。

#### 自主安全性机制

自主安全性访问规则的一般形式：(S, O, t, P)

- S：请求主体（用户）
- O：访问对象
- t：访问权利
- P：谓词（拥有权利需满足的条件）

控制方法：**按名控制**（仅涉及S、O、t），**按内容控制**（涉及S、O、t、P）。

实现方式：**存储矩阵**、**视图**。

##### 权利级别

1. 读
2. 更新（插入元组、更新元组、删除元组）
3. 创建（创建表等、更新表等、删除表等）

高级别权利自动包含低级别权利。

级别3权利称为**账户级别**权利，级别1和2称为**关系级别**权利。

## 第9-10讲 嵌入式SQL语言

### 基本概念

#### 静态SQL与动态SQL

静态SQL：SQL语句已在程序中写好，使用时仅需传递变量值。

动态SQL：SQL语句在程序中动态构造，形成字符串，然后交由DBMS执行，执行时仍可传递变量。

#### 数据字典

**数据字典**：又称**系统目录**或**元数据**，是系统维护的一些表或视图的集合，其中存储了数据库中各类对象的定义信息。数据字典可使用SQL语句访问。

组成：关系信息、用户账户信息（包括密码）、统计与描述性数据、物理文件组织信息、索引信息。

#### SQLDA

**SQLDA**：SQL描述区，内存数据结构，装载着关系模式的定义信息。不同DBMS提供的SQLDA格式并不一致。

#### 事务

**事务**：存取或改变数据库内容的程序的一次执行（一条或多条SQL语句的一次执行）。DBMS通过事务提供一致性状态转换。

##### 特性

- 原子性：保证事务的一组操作原子不可分。
- 一致性：保证事务的操作状态符合一致性操作规则。
- 隔离性：保证并发执行的多个事务之间互相不受影响。
- 持久性：保证已提交事务的影响是持久的。

#### 游标

**游标**：指向某检索记录集的指针，**只能单向移动**。游标读完全部记录时以EOF标识。

**可滚动游标**：由ODBC提供支持，**可在记录集上任意移动**。游标移动至记录集首时以BOF标识。

### 嵌入式SQL语句

- 变量声明：begin declare section; 类型 变量名 \[=初始化值\]; end declare section;

  以此方式声明的字符串长度不包括'\\0'。

- 数据库连接：

  - 连接：
    - connect to 目标服务器 as 连接名 user 用户名;
    - connect to default;
  - 断开连接：
    - disconnect 连接名;
    - disconnect current;

- 执行动态SQL语句：

  - 运行时编译并执行：

    - execute immediate :SQL语句字符串;

      立即编译执行的语句必须为完整SQL语句。

  - 先编译后执行：

    - 编译：prepare 语句名 from :SQL语句字符串;
    - 执行：execute 语句名 using :宿主变量;

- 提交/撤销执行：

  - 提交：commit work;
  - 撤销：rollback work;

  程序员需要通过提交/撤销语句确认事务结束。

- 游标：

  - declare 游标名 \[Scroll\] cursor for 查询语句;

    定义一个游标，但不执行查询语句。

    Scroll：加入该选项则定义可滚动游标。

  - open 游标名;

    执行游标对应的查询语句，并将游标指向结果首部。**游标可被多次打开**。

  - close 游标名;

    关闭游标。

- 数据交互：

  - 读取记录：

    - 单行记录：select 表达式 \[\[, 表达式\] ...\] into :宿主变量\[\[, :宿主变量\] ...\] ... ;

      将查询得到的单行结果直接赋值给宿主变量。注意**宿主变量前有引号**。

    - 多行记录：fetch \[Next|Prior|First|Last|\[Absolute|Relative\] 偏移量\] 游标名 into 宿主变量列表;

      使游标读出一条记录。

      对于可滚动游标，可使用语句中的可选项以控制游标移动。偏移量可正可负。

  - 删除记录：

    - 常规delete语句

    - delete ... where current of 游标名;

      删除游标所在位置的记录。

  - 更新记录：

    - 常规update语句

    - update ... where current of 游标名;

      更新游标所在位置的记录。

  - 插入记录：

    - 常规insert语句，**并无游标插入方式**。

- 状态捕获及错误处理：

  - include sqlca;

    设置SQL通信区，使宿主程序能与DBMS交流。

  - whenever 状态 动作;

    捕获状态并执行指定动作（如goto）。该语句定义的捕获作用域以同样的条件再次被定义捕获为止。

    由于条件捕获由预编译程序处理，故**作用域以代码区域为准，而非程序控制流**。

    常见状态：

    - SQLERROR：SQL语句出错。其具体意义依赖于DBMS。
    - NOT FOUND：执行SQL语句后无结果记录。
    - SQLWARNING：并非错误，但应引起注意的条件。

    常见动作：

    - continue：继续执行。
    - goto 标签：跳转至标签位置语句执行。
    - stop：终止程序执行，撤销当前事务，断开数据库连接。
    - do 函数/call 函数：调用宿主程序的函数。调用结束后返回触发条件的SQL语句之后继续执行。

  - 非SQL语句方法：

    - 状态记录变量：sqlcode、sqlca.sqlcode、sqlstate

      不同DBMS各自支持上述变量中的一种或几种，用于记录执行SQL语句的状态。

## 第10讲 数据库标准接口

### ODBC

**ODBC**：不同语言的应用程序与不同数据库服务器间通讯的标准。

**SQLCA**：SQL通讯区，记录着SQL语句被DBMS执行后返回的状态信息。

连接默认启用自动提交特性，自动提交每一条SQL语句，可手动关闭后手动提交。

连接步骤：

1. SQLAllocEnv()
2. SQLAllocConnect()
3. SQLConnect()
4. 进行工作：
   - 发送SQL命令：SQLExecDirect()
   - 获取结果：SQLFetch()
   - 绑定宿主变量与结果属性：SQLBindCol()
5. SQLDisconnect()
6. SQLFreeConnect()
7. SQLFreeEnv()

### JDBC

**JDBC**：提供Java应用程序与数据库服务器的连接和通讯能力。

常见类：

- java.sql.DriverManager：处理驱动的调入，支持产生新数据库连接。
- java.sql.Driver：通过驱动进行数据库访问。
- java.sql.Connection：对特定数据库的连接。
- java.sql.Statement：对特定的数据库执行的SQL语句。
- java.sql.PreparedStatement：用于执行预编译的SQL语句。
- java.sql.CallableStatement：用于执行对数据库内嵌过程的调用。
- java.sql.ResultSet：从当前执行的SQL语句中返回结果数据。

连接步骤：

1. 传递Driver给DriverManager加载数据库驱动。
2. 通过URL得到Connection对象，建立数据库连接。
3. 进行工作：
   - 使用Statement对象查询或修改数据库（查询和修改使用不同的函数）。
   - 查询返回ResultSet对象。
   - 使用结束后关闭Statement对象。
4. 关闭连接。

## 第11-12讲 数据建模思想与方法

### 抽象层次

#### 模型与元模型

**元模型**：对模型的抽象，由一组**抽象概念**及其之间关系构成。

**模型**：依据元模型中的抽象概念及关系对现实世界进行理解，获得**具体概念**及其具体关系而构成。

#### 数据模型与概念模型

**数据模型**：表达计算机世界的模型。如关系模型、网状模型、层次模型。

**概念模型**：表达信息世界的模型。如E-R模型。

### E-R模型

基本概念：

- **实体**：客观存在并可相互区分的事物，具有“类”和“个体”的概念，分别称为“实体”与“实例”。

- **属性**：实体具有的某一方面特性。实体具有属性（对应于列名），实例也具有属性（对应于列值）。

  属性的分类方式：

  - **单一属性**与**复合属性**
  - **单值属性**与**多值属性**
  - **可空值属性**与**非空值属性**
  - **原始属性**与**导出属性**（由其他属性计算而得）

- **联系**：一个实体的实例和其他实体实例之间可能发生的联系。

  **度（元）**：参与联系的实体（不是实例）数目。

  **角色**：实体在联系中的作用。当同一实体的不同实例参与一个联系时，为区别各实例参与联系的方式，需显式指明其角色。

  **基数**：一个实体的实例通过一个联系能与另一实体中实例相关联的数目。

  联系的分类方式：

  - 二元联系分类：**一对一联系**、**一对多联系**、**多对多联系**（此处“一”“多”指实例数目）
  - 联系端点分类：**完全参与联系**（该端实例最小基数为1）、**部分参与联系**（该端实例最小基数为0）

  实体是相对稳定的，但联系是多样化的。

- **关键字（码）**：实体中能用其值唯一区分开每一实例的属性或属性组合。

#### 图示方法

- Chen方法

  实体：矩形

  属性：椭圆

  - 多值属性：双线椭圆
  - 导出属性：虚线椭圆
  - 复合属性：属性与子属性间连线

  关键字：属性名加下划线

  - 复合关键字：下划线下标出相同数字
  - 多组关键字：下划线下标出不同数字

  联系：菱形

  属性属于某一实体/联系：直线连接

  联系连接某些实体：直线连接

  - 区分一对一、一对多、多对多联系：
    - 实体基数为1：有箭头，箭头指向实体
    - 实体基数大于1：无箭头
  - 区分部分参与联系、完全参与联系：
    - 部分参与联系：单直线（**即基数范围为0\~n**）
    - 完全参与联系：双直线
  - 上述两种区分也可通过在联系直线旁标注基数/基数范围进行区分。最大基数不确定时可简记为m或n。
  - 角色：连接直线上标记角色名

- Crow's Foot方法

  实体：分为上下两格的矩形框，实体名称在上格中

  属性：实体框的下格中

  关键字：属性名加下划线

  联系：菱形；或省略边框，直接以联系名表示

  - 区分基数：
    - 基数范围一端为0的，在**直线内**写0
    - 基数范围一端为1的，在**直线内**写1
    - 基数可大于1的，直线另一端为爪形

  其余未说明特性与Chen方法相同。

- IDEF1X方法（工程化方法）

  - 概念：

    实体分为**独立实体**与**从属实体**。

    - **独立实体**（强实体）：其关键字与它和其它实体的联系无关（不从其它实体继承属性用作关键字）。即**主键中不含外键**。
    - **从属实体**（弱实体）：其关键字的一部分（或全部）属性是从其它实体主关键字继承而来。即**主键中包含外键**。

    作用名：实体中的外键在该实体中的重新命名。

    联系的分类：

    - **连接联系**（父子联系、依存联系）：一对多的联系，一端称为父实体，多端称为子实体。
      - **标定联系**：从属实体与其父实体间的联系，子实体主键中包含来自父实体的外键。
      - **非标定联系**：两个不具有从属关系的实体间的联系，子实体非主键中包含来自父实体的外键。
    - **非确定联系**：多对多的联系，需要引入相交实体拆分为一对多联系进行表达。
    - **分类联系**：联系一般实体与多个分类实体的联系。分类实体具有与一般实体相同的主键，但各自可能有更多的属性。**至少有一个分类实体需要有更多的属性。**
      - **完全分类联系**：各个分类实体实例集的并集恰好为一般实体实例集。
      - **非完全分类联系**：各个分类实体实例集的并集小于一般实体实例集。

    具体化/泛化：

    - 具体化：在实体的实例集中，根据一些实例与其它实例不同的特性，对实例集进行划分。

    - 泛化：若干个实体根据共有的性质，合成一个较高层的实体。与具体化互逆。

      具体化与泛化在E-R图中以**标记为ISA的三角形**表示。

  - 规则：

    - 相同的含义总是使用同一名称，不同含义总是使用不同名称。（实体名、属性名、作用名）
    - 单主规则：实体可以具有任意个属性，一个属性只能归属于一个实体。
    - 非空规则：每一个实例的每一个属性必须具有一个值。
    - 非重复规则：实例的每一个属性仅能具有一个值。
    - 最小关键字规则：任意一组关键字中任意去除一个属性，都无法唯一确定实例。
    - 完全函数依赖规则：当主键不仅一个属性时，非键属性值须完全函数依赖于主键。即若仅确定一部分主键，无法唯一确定非键属性值。
    - 非传递依赖规则：非键属性不能由其它非键属性值确定。

  - 图示：

    实体：分为上下两格的矩形框，实体名及实体号在框上方，主键在上格，次键及其它属性在下格。外键后标有“(FK)”字样，次键后标有“(AK n)”字样，不同组的次键以标号n不同进行区分。若外键有重命名，则写作“作用名.继承属性名(FK)”。

    - 独立实体：方角矩形框
    - 从属实体：圆角矩形框

    联系：直线

    - 连接联系：子实体端以圆圈为端点，可标注基数为P（大于0）/Z（0或1）/具体数/省略（非负）。联系名标注于直线旁。
      - 标定联系：直线为实线
      - 非标定联系：直线为虚线
    - 分类联系：由一般实体端发出直线，以圆圈结尾。圆圈对端有单/双短线垂直于原直线，短线上发出若干直线到达各分类实体。用于分类的属性名（称鉴别器属性）标注于短线旁。**分类实体的主关键字可不标识**。
      - 完全分类联系：双短线
      - 非完全分类联系：单短线

## 第13讲 数据库设计过程

### 需求分析

- 了解部分-岗位划分。
- 收集每一岗位的“源”（报表、单据、查询需求、管理需求等），形成源表。
- 理解每一“源”，包括源的属性构成、处理规则、属性处理规则等。
- 提交需求分析报告。

### 概念数据库设计

- 识别实体与联系。
- 绘制E-R图或IDEF1X图，表达业务规则。
- 定义实体、联系及实体的属性构成。
- 提交概念数据库设计报告

### 逻辑数据库设计

- 概念图转换为关系模型。
- 检查逻辑数据库设计正确性。
- 定义全局模式和外模式。
- 提交逻辑数据库设计报告。

#### 概念图转关系模式

E-R图：

- 实体、属性、关键字分别直接转换为关系、属性、关键字。
- 对于复合属性，可将各个分量作为单独的属性，也可将整个复合属性作为一个属性。
- 对于多值属性，将该属性与实体关键字组成一个新的关系。
- 对于一对一联系：
  - 联系有一方全部参与时，将另一方关键字作为全部参与一方关系的属性。
  - 联系双方均部分参与时，将联系定义为一个新的关系，属性为双方关键字。
- 对于一对多联系，将单方参与实体的关键字作为多方参与实体的属性。
- 对于多对多联系，将联系定义为新的关系，属性为双方实体关键字。
- 对于多元联系，可继承参与联系的各个实体的关键字形成新的关系，可选择新增一个区分属性（如序号）。多元联系也可转化为多个二元联系。
- 泛化实体与具体化实体转为不同的关系，低层实体的关系包含高层实体的关键字。但若泛化实体被完全分类，则泛化实体可以不转为关系，由低层实体的关系包括上层所有属性。

IDEF1X图：

- 仅需将实体转换为关系，无需处理联系。
- 其余参照E-R图处理方式即可。

#### 不正确数据库的可能问题

- 非受控冗余问题：数据存在冗余（某些数据联系反复出现）时，若修改数据，所有冗余数据需同步更新。
- 插入异常：插入不全确定的记录时，数据含义变得不明。
- 删除异常：某些信息仅依靠与其关联的记录存储时，若这些记录全部被删除，则这些信息将随之丢失。

#### 数据库设计理论

- 数据依赖理论
- 关系范式理论
- 模式分解理论

### 物理数据库设计

- 利用具体DBMS创建数据库/表。
- 使用与具体DBMS相关的理论知识确定物理存储方式与存储空间。
- 创建索引、视图等。
- 提交物理数据库设计报告。

